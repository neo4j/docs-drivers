= Query the database

You can run a query against the database using <<Cypher>> and the methods `Session.executeRead()` and `Session.executeWrite()`.


== Write to the database

To create a node representing a person named `Alice`, use the `Session.executeWrite()` method in combination with the link:{neo4j-docs-base-uri}/cypher-manual/current/clauses/merge/[`MERGE`] clause:

.Create a node representing a `Person` named `Alice`
[source, javascript]
----
var session = driver.session(database='neo4j')

var summary = await session.executeWrite(async tx => {  // <3>
  let result = await tx.run(
    'MERGE (p:Person {name: $name})', {  // <1>
     name: 'Alice'  // <2>
  })
  return result.summary
})

  console.log(`Created ${summary.counters.updates().nodesCreated} nodes in ${summary.resultAvailableAfter} ms.`)

  session.close()
----

where *(1)* specifies the Cypher query and *(2)* is a _query parameter_.
The query execution is delegated to an anonymous transaction function, which is passed as callback to `Session.executeWrite()` *(3)*.

[NOTE]
`MERGE` creates a new node matching the requirements unless one already exists, in which case nothing is done.
For strict node creation, use the link:{neo4j-docs-base-uri}/cypher-manual/current/clauses/create/[`CREATE`] clause.


== Read from the database

To retrieve information from the database, use the `Session.executeRead()` method in combination with the link:{neo4j-docs-base-uri}/cypher-manual/current/clauses/match/[`MATCH`] clause:

.Retrieve all `Person` nodes
[source, javascript, role=nocollapse]
----
var session = driver.session(database='neo4j')

var {records, summary} = await session.executeRead(async tx => {
  let result = await tx.run('MATCH (p:Person) RETURN p.name AS name')
  return {records: result.records, summary: result.summary}
})

console.log(`The query \`${summary.query.text}\` returned ${records.length} nodes.\n`)

for(let record of records) {
  console.log(`Person with name: ${record.get('name')}`)
  console.log(`Available properties for this node are: ${record.keys}\n`)
}
----

where `records` contains the actual result as a list of link:{neo4j-docs-base-uri}/api/javascript-driver/current/class/lib6/record.js~Record.html[`Record`] objects, and `summary` is a link:{neo4j-docs-base-uri}/api/javascript-driver/current/class/lib6/result-summary.js~ResultSummary.html[`ResultSummary`] object, containing a summary of execution from the server.


== Update the database

To update a node's information in the database, use `MATCH` together with the link:{neo4j-docs-base-uri}/cypher-manual/current/clauses/set/[`SET`] clause in a `Session.executeWrite()` call:

.Update node `Alice` to add an `age` property
[source, javascript]
----
var session = driver.session(database='neo4j')

var summary = await session.executeWrite(async tx => {
  let result = await tx.run(`
    MATCH (p:Person WHERE name = $name)
    SET p.age = $age
    `, { name: 'Alice', age: 42 }
  )
  return result.summary
})

console.log(`Query counters:`)
console.log(summary.counters.updates())
----

To create new nodes and relationships linking it to an already existing node, use a combination of `MATCH` and `MERGE` in a `Session.executeWrite()` call:

.Create a relationship `KNOWS` between `Alice` and `Bob`
[source, javascript]
----
var session = driver.session(database='neo4j')

var summary = await session.executeWrite(async tx => {
  let result = await tx.run(`
    MATCH (p:Person WHERE p.name = $name)
    MERGE (friend:Person {name: $friend_name})
    MERGE (p)-[:KNOWS]->(friend)
    `, { name: 'Alice', friend_name: 'Bob' }
  )
  return result.summary
})

console.log(`Query counters:`)
console.log(summary.counters.updates())
----

[WARNING]
====
It may feel tempting to create new relationships with a single `MERGE` clause, such as: +
`MERGE (:Person {name: "Alice"})-[KNOWS]->(:Person {name: "Bob"})`. +
However, this would result in the creation of an _extra_ `Alice` node, so that you would end up with unintended duplicate records.
To avoid this, always break out a path creation: `MATCH` (or `MERGE`) the nodes you need, and use the resulting references to `MERGE` the relationship (as shown in the previous example).
See link:https://neo4j.com/developer/kb/understanding-how-merge-works/[Understanding how MERGE works].
====


== Delete from the database
To remove a node and any relationship attached to it, use link:{neo4j-docs-base-uri}/cypher-manual/current/clauses/delete/[`DETACH DELETE`] in a `Session.executeWrite()` call:

.Remove the `Alice` node
[source, javascript]
----
var session = driver.session(database='neo4j')

var summary = await session.executeWrite(async tx => {
  let result = await tx.run(`
    MATCH (p:Person WHERE p.name = $name)
    DETACH DELETE p
    `, { name: 'Alice' }
  )
  return result.summary
})

console.log(`Query counters:`)
console.log(summary.counters.updates())
----


[#query-parameters]
== How to pass parameters to queries

*Do not hardcode or concatenate parameters directly into queries*.
Instead, always use placeholders and specify the link:{neo4j-docs-base-uri}/cypher-manual/current/syntax/parameters/[Cypher parameters] as keyword arguments or in a dictionary, as shown in the previous examples.
This is for:

1. *performance benefits*: Neo4j compiles and caches queries, but can only do so if the query structure is unchanged;
2. *security reasons*: link:https://neo4j.com/developer/kb/protecting-against-cypher-injection/[protecting against Cypher injection].

[NOTE]
There can be circumstances where your query structure prevents the usage of parameters in all its parts.
For those advanced use cases, see xref:query-advanced#_dynamic_values_in_property_keys_relationship_types_and_labels[Dynamic values in property keys, relationship types, and labels].


== Anatomy of a query

Before you can run a query, you need to obtain a session from the driver with the `Driver.session()` method *(1)*.
The `database` parameter is optional but recommended for xref:performance.adoc[performance], and further xref:transactions#_session_configuration[configuration parameters] can be included.

Within a session, use the methods link:{neo4j-docs-base-uri}/api/javascript-driver/current/class/lib6/session.js~Session.html#instance-method-executeRead[`Session.executeRead()`] and link:{neo4j-docs-base-uri}/api/javascript-driver/current/class/lib6/session.js~Session.html#instance-method-executeWrite[`Session.executeWrite()`] *(2)*, depending on whether you want to retrieve data from the database or alter it.
Both methods take a _transaction function_ callback.

The callback transaction function is responsible for actually carrying out the queries and xref:result.adoc[processing the result].
Queries are specified with the link:{neo4j-docs-base-uri}/api/javascript-driver/current/class/lib6/transaction.js~Transaction.html#instance-method-run[`Transaction.run()`] method *(3)*, which takes a query and its parameters (as an object *(4)*), and returns a link:{neo4j-docs-base-uri}/api/javascript-driver/current/class/lib6/result.js~Result.html[`Result`] object.
You may then result the result records and summary for later usage *(5)*.

.Retrieve people whose name starts with `Al`.
[source, javascript]
----
var session = driver.session(database='neo4j')  // <1>

var {records, summary} = await session.executeRead(async tx => {  // <2>
  let result = await tx.run(`  // <3>
    MATCH (p:Person WHERE p.name STARTS WITH $filter)
    RETURN p.name AS name ORDER BY name
    `, { filter: 'Al'}  // <4>
  )
  return {records: result.records, summary: result.summary}  // <5>
})

console.log(`The query \`${summary.query.text}\` returned ${records.length} nodes.\n`)

for(let record of records) {
  console.log(`Person with name: ${record.get('name')}`)
  console.log(`Available properties for this node are: ${record.keys}\n`)
----

You can find more information about sessions and transactions in the section xref:transactions.adoc[Run your own transactions].

[TIP]
The driver may automatically retry to run a failed transaction.
For this reason, *transaction functions must be _idempotent_* (i.e., they should produce the same effect when run several times), because you do not know how many times they might be executed.
In practice, this means that you should not edit nor rely on globals, for example.
Note that although transactions functions might be executed multiple times, the queries inside it will always run only once.


== A full example

[source, javascript]
----
(async () => {
  var neo4j = require('neo4j-driver')

  const URI = 'neo4j://localhost'
  const USER = 'neo4j'
  const PASSWORD = 'verysecret'

  let people = [{"name": "Alice", "age": 42, "friends": ["Bob", "Peter", "Anna"]},
                {"name": "Bob", "age": 19},
                {"name": "Peter", "age": 50},
                {"name": "Anna", "age": 30}]

  try {
    var driver = neo4j.driver(URI,  neo4j.auth.basic(USER, PASSWORD))
    await driver.verifyConnectivity()
  } catch(err) {
    return
    console.log(`Connection error\n${err}\nCause: ${err.cause}`)
  }

  var session = driver.session(database='neo4j')

  // Create some nodes
  for(let person of people) {
    await session.executeWrite(async tx => {
      await tx.run("MERGE (p:Person {name: $person.name, age: $person.age})",
                   {person: person}
      )
    })
  }

  // Create some relationships
  for(let person of people) {
    if(person.friends != undefined) {
      await session.executeWrite(async tx => {
        tx.run(`
          MATCH (p:Person {name: $person.name})
          UNWIND $person.friends AS friend_name
          MATCH (friend:Person {name: friend_name})
          MERGE (p)-[:KNOWS]->(friend)
          `, {person: person}
        )
      })
    }
  }

  // Retrieve Alice's friends who are under 40
  var {records, summary} = await session.executeRead(async tx => {
    let result = await tx.run(`
      MATCH (p:Person {name: $name})-[:KNOWS]-(friend:Person)
      WHERE friend.age < $age
      RETURN friend
      `, {name: 'Alice', age: 40}
    )
    return {records: result.records, summary: result.summary}
  })

  // Loop through results and do something with them
  for(let person of records) {
    // `person.friend` is an object of type Node
    console.log(person.get('friend'))
  }

  // Summary information
  console.log(`The query \`${summary.query.text}\` returned ${records.length} records in ${summary.resultAvailableAfter} ms.`)

  await driver.close()
})();
----

ifndef::backend-pdf[]
[discrete.glossary]
== Glossary

include::{common-partial}/glossary.adoc[]
endif::[]
