[[driver-client-applications]]
= Client applications

# tag::abstract[]

[abstract]
--
This section describes how to manage database connections within an application.
--

# end::abstract[]


[[driver-driver-object]]
== The Driver Object

# tag::object-pt1[]

Neo4j client applications require a *_Driver Object_* which, from a data access perspective, forms the backbone of the application.
It is through this object that all Neo4j interaction is carried out, and it should therefore be made available to all parts of the application that require data access.

In languages where <<term-thread-safety, thread safety>> is an issue, the Driver Object can be considered *_thread-safe_*.


[TIP]
.A note on lifecycle
--
Applications will typically construct a Driver Object on startup and destroy it on exit.

Destroying a Driver Object will immediately shut down any connections previously opened via that Driver Object, by closing the associated connection pool.

This will have the consequence of rolling back any open transactions, and closing any unconsumed results.
--

# end::object-pt1[]

To construct a driver instance, a <<driver-connection-uris, connection URI>> and <<driver-authentication, authentication information>> must be supplied.

# tag::object-pt2[]

Additional configuration details can be supplied if required.
The configuration details are immutable for the lifetime of the Driver Object.
Therefore, if multiple configurations are required (such as when working with multiple database users) then multiple Driver Objects must be used.

# end::object-pt2[]

[.tabbed-example]
.The driver lifecycle
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=driver-lifecycle]
----

// .Import driver lifecycle
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=driver-lifecycle-import]
// ----
======


[.include-with-java]
======
.Import driver lifecycle
[source, java]
----
include::{java-examples}/DriverLifecycleExample.java[tags=driver-lifecycle-import]
----

[source, java]
----
include::{java-examples}/DriverLifecycleExample.java[tags=driver-lifecycle]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=driver-lifecycle]
----

// .Import driver lifecycle
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=driver-lifecycle-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_driver_lifecycle_example.py[tags=driver-lifecycle-import]
----

[source, python]
----
include::{python-examples}/test_driver_lifecycle_example.py[tags=driver-lifecycle]
----
======
====


[[driver-connection-uris]]
== Connection URIs

# tag::uris[]

A connection URI identifies a graph database and how to connect to it.

The *_encryption_* and *_trust_* settings provide detail to how that connection should be secured.

[CAUTION]
====
*There are significant changes to security settings between Neo4j 3.x and Neo4j 4.x*

Please consider the information in this section before upgrading from a previous version.

The https://neo4j.com/docs/migration-guide/current/[Migration Guide] is also a good source of information about changes in functionality.
====

Starting with *Neo4j 4.0*, client-server communication uses only *_unencrypted local connections by default_*.

This is a change from previous versions, which switched on encryption by default, but generated a self-signed certificate out of the box.

When a full certificate is installed, and encryption is enabled on the driver, full certificate checks are carried out (refer to <<operations-manual#ssl-framework, Operations Manual -> SSL framework >>).
Full certificates provide better overall security than self-signed certificates as they include a complete chain of trust back to a root certificate authority.

# end::uris[]

[NOTE]
====
https://neo4j.com/aura/[*Neo4j Aura*] is a *_secure hosted service_* backed by full certificates signed by a root certificate authority.

To connect to *Neo4j Aura*, driver users must *_enable encryption_* and the complete set of certificate checks (the latter of which are enabled by default).

For more information, see <<driver-configuration-examples>> below.
====

# tag::default-security-changes[]

.Changes in default security settings between 3.x and 4.x
[options="header"]
|===
| Setting | Neo4j 4.x | Neo4j 3.x (Drivers 1.x)
| Bundled certificate | none | auto-generated, self-signed
| Driver encryption   | off  | on
| Bolt interface      | localhost |localhost
| Certificate expiry check  | on  |on
| Certificate CA check  | on  | off
| Certificate hostname check  | on  | off
|===

# end::default-security-changes[]


[[initial-address-resolution]]
=== Initial address resolution

# tag::initial-address-resolution[]

The address provided in a `neo4j://` URI is used for initial and fallback communication only.

This communication occurs *_to bootstrap the routing table_*, through which all subsequent communication is carried out.
Fallback occurs when the driver is unable to contact any of the addresses held in the routing table.
The initial address is once again reused to bootstrap the system.

Several options are available for providing this initial logical-to-physical host resolution.
These include *_regular DNS_*, *_custom middleware_* such as a load balancer, and the Driver Object *_resolver function_*, all of which are described in the following sections.

# end::initial-address-resolution[]


[[dns-resolution]]
==== DNS resolution

# tag::dns-resolution[]

DNS resolution is the default, and always-available option.
As it is possible to configure DNS to resolve a single host name down to multiple IP addresses, this can be used to expose all core server IP addresses under a single host name.

image::dns-resolution.png[title="Initial address resolution over DNS", role="middle"]

# end::dns-resolution[]


[[custom-middleware]]
==== Custom middleware

# tag::custom-middleware[]

Middleware, such as a load balancer, can be used to group the core servers under a single public address.

image::custom-middleware.png[title="Initial address resolution using custom middleware"]

# end::custom-middleware[]


[[driver-resolver-function]]
==== Resolver function

# tag::resolver-function[]

Neo4j Drivers also present an address resolution intercept hook called the *_resolver function_*.

This takes the form of a callback function that accepts a single input address and returns multiple output addresses.
The function may hard code the output addresses or may draw them from another configuration source, as required.

image::resolver-function.png[title="Initial address resolution using resolver function"]

The example below shows how to expand a single address into multiple (hard-coded) output addresses:

# end::resolver-function[]

[.tabbed-example]
.Custom Address Resolver
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-custom-resolver]
----
======

[.include-with-java]
======
[source, java]
----
include::{java-examples}/ConfigCustomResolverExample.java[tags=config-custom-resolver]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-custom-resolver]
----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_custom_resolver_example.py[tags=custom-resolver-import]
----

[source, python]
----
include::{python-examples}/test_custom_resolver_example.py[tags=custom-resolver]
----
======

====


[[driver-routing-table]]
=== Routing table

# tag::routing-table[]

The routing table acts like the glue between the driver connectivity layer and the database surface.
This table contains a list of server addresses, grouped as *_readers_* and *_writers_*, and is refreshed automatically by the driver as required.

The driver does not expose any API to work directly with the routing table, but it can sometimes be useful to explore when troubleshooting a system.

# end::routing-table[]


[[driver-routing-context]]
=== Routing context

# tag::routing-context[]

A routing context can be included as the query part of a `neo4j://` URI.

Routing contexts are defined by means of *_server policies_* and allow customization of the contents of the routing table.

.Configure a routing driver with routing context
====
This example will assume that *Neo4j* has been configured for server policies as described in <<operations-manual#multi-dc-load-balancing, Neo4j Operations Manual -> Load balancing for multi-data center systems>>.
In particular, a server policy called `europe` has been defined.
Additionally, we have a server `neo01.graph.example.com` to which we wish to direct the driver.

This URI will use the server policy `europe`:

`neo4j://neo01.graph.example.com?policy=europe`
====

[NOTE]
.Server-side configuration to enable routing drivers with routing context
====
A prerequisite for using a routing driver with routing context is that the *Neo4j* database is operated on a <<operations-manual#clustering, Causal Cluster>> with the <<operations-manual#multi-dc, Multi-data center licensing option>> enabled.
Additionally, the routing contexts must be defined within the cluster as *_routing policies_*.

For details on how to configure *_multi-data center routing policies_* for a Causal Cluster, please refer to <<operations-manual#multi-dc-load-balancing, Operations Manual -> Causal Clustering>>.
====

[NOTE]
.Exposing a single instance deployment on a remote host using the `neo4j` URI scheme
====
If you are using a *_single instance_* of *Neo4j*, deployed on a remote machine whilst using the `neo4j` URI scheme, *_you will need to complete additional configuration of the server_*.

To make the server aware of its deployment environment, you need to configure
<<operations-manual#config_dbms.default_advertised_address,`default_advertised_address`>>
with your deployment machine's host name, as visible from the client machine.
====

# end::routing-context[]


[[driver-configuration-examples]]
=== Examples

# tag::examples-pt1[]

*_Connection URIs_* are typically formed according to the following pattern:

[source, shell]
----
neo4j://<HOST>:<PORT>[?<ROUTING_CONTEXT>]
----

This targets a routed *Neo4j* service that may be fulfilled by either a cluster or a single instance.
The `HOST` and `PORT` values contain a logical hostname and port number targeting the entry point to the *Neo4j* service (e.g. `neo4j://graph.example.com:7687`).

# end::examples-pt1[]

In a clustered environment, the URI address will resolve to one of more of the core members; for standalone installations, this will simply point to that server address.
The `ROUTING_CONTEXT` option allows for customization of the routing table and is discussed in more detail in <<driver-routing-context>>.

# tag::examples-pt2[]

An alternative URI form, using the `bolt` URI scheme (e.g. `bolt://graph.example.com:7687`), can be used when a *_single point-to-point connection is required_*.
This variant is useful for the subset client applications (such as admin tooling) that need to be aware of individual servers, as opposed to those which require a highly available database service.

[source, shell]
----
bolt://<HOST>:<PORT>
----

Each of the `neo4j` and `bolt` URI schemes permit variants that contain extra encryption and trust information.
The `+s` variants enable encryption with a full certificate check, and the `+ssc` variants enable encryption, but with no certificate check.
This latter variant is designed specifically for use with self-signed certificates.

.Available URI schemes
[options="header", cols="m,a,a"]
|===
|URI scheme
|Routing
|Description

|neo4j
|Yes
|Unsecured

|neo4j+s
|Yes
|Secured with full certificate

|neo4j+ssc
|Yes
|Secured with self-signed certificate

|bolt
|No
|Unsecured

|bolt+s
|No
|Secured with full certificate

|bolt+ssc
|No
|Secured with self-signed certificate

|===

[NOTE]
*Neo4j 3.x* did not provide a routing table in single instance mode and therefore you should use a `bolt://` URI if targeting an older, non-clustered server.

The table below provides example code snippets for different deployment configurations.
Each snippet expects an `auth` variable to have been previously defined, containing the authentication details for that connection.

# end::examples-pt2[]

[.tabbed-example]
.Connecting to a service
====
[.include-with-dotnet]
======
The table below illustrates examples of how to connect to a service with routing:

[cols="a,a"]
|===
|Product |Neo4j Aura
|Security |Secured with full certificate
|Code snippet |
[source, csharp]
----
GraphDatabase.Driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted));
----
|Comments | This is the default (and only option) for Neo4j Aura

|Neo4j 4.x
|Unsecured
|
[source, csharp]
----
GraphDatabase.Driver("neo4j://graph.example.com:7687", auth);
----
|This is the default for Neo4j 4.x series

|Neo4j 4.x
|Secured with full certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted));
----
|

|Neo4j 4.x
|Secured with self-signed certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted)
                 .WithTrustManager(TrustManager.CreateInsecure()));
----
|

|Neo4j 3.x
|Secured with full certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted));
----
|

|Neo4j 3.x
|Secured with self-signed certificate
|
[source, csharp]
----
GraphDatabase.Driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the .NET Driver 4.0.1 patch installed, you will need this snippet instead:

[source, csharp]
----
String uri = "neo4j://graph.example.com:7687";
IDriver driver = GraphDatabase.Driver(uri, auth,
           o => o.WithEncryptionLevel(EncryptionLevel.Encrypted)
                 .WithTrustManager(TrustManager.CreateInsecure()));
----
|This is the default for Neo4j 3.x series

|Neo4j 3.x
|Unsecured
|
[source, csharp]
----
GraphDatabase.Driver("neo4j://graph.example.com:7687", auth);
----
|

|===

[NOTE]
To connect to a service without routing, you can replace `neo4j` with `bolt`.

======

[.include-with-java]
======
The table below illustrates examples of how to connect to a service with routing:

[options="header", cols="a,a,a,a"]
|===
|Product
|Security
|Code snippet
|Comments

|Neo4j Aura
|Secured with full certificate
|
[source, java]
----
GraphDatabase.driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the Java Driver 4.0.1 patch installed, you will need this snippet instead:

[source, java]
----
String uri = "neo4j://graph.example.com:7687";
Config config = Config.builder()
                     .withEncryption()
                     .build();
Driver driver = GraphDatabase.driver(uri, auth, config);
----
| This is the default (and only option) for Neo4j Aura

|Neo4j 4.x
|Unsecured
|
[source, java]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth)
----
|This is the default for Neo4j 4.x series

|Neo4j 4.x
|Secured with full certificate
|
[source, java]
----
GraphDatabase.driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the Java Driver 4.0.1 patch installed, you will need this snippet instead:

[source, java]
----
String uri = "neo4j://graph.example.com:7687";
Config config = Config.builder()
                     .withEncryption()
                     .build();
Driver driver = GraphDatabase.driver(uri, auth, config);
----
|

|Neo4j 4.x
|Secured with self-signed certificate
|
[source, java]
----
GraphDatabase.driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the Java Driver 4.0.1 patch installed, you will need this snippet instead:

[source, java]
----
String uri = "neo4j://graph.example.com:7687";
Config config = Config.builder()
                    .withEncryption()
                    .withTrustStrategy( trustAllCertificates() )
                    .build();
Driver driver = GraphDatabase.driver(uri, auth, config);
----
|

|Neo4j 3.x
|Secured with full certificate
|
[source, java]
----
GraphDatabase.driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the Java Driver 4.0.1 patch installed, you will need this snippet instead:

[source, java]
----
String uri = "neo4j://graph.example.com:7687";
Config config = Config.builder()
                     .withEncryption()
                     .build();
Driver driver = GraphDatabase.driver(uri, auth, config);
----
|

|Neo4j 3.x
|Secured with self-signed certificate
|
[source, java]
----
GraphDatabase.driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the Java Driver 4.0.1 patch installed, you will need this snippet instead:

[source, java]
----
String uri = "neo4j://graph.example.com:7687";
Config config = Config.builder()
                    .withEncryption()
                    .withTrustStrategy( trustAllCertificates() )
                    .build();
Driver driver = GraphDatabase.driver(uri, auth, config);
----
|This is the default for Neo4j 3.x series

|Neo4j 3.x
|Unsecured
|
[source, java]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth)
----
|

|===

[NOTE]
To connect to a service without routing, you can replace `neo4j` with `bolt`.

======

[.include-with-javascript]
======
The table below illustrates examples of how to connect to a service with routing:

[options="header", cols="a,a,a,a"]
|===
|Product
|Security
|Code snippet
|Comments

|Neo4j Aura
|Secured with full certificate
|
[source, javascript]
----
neo4j.driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the JavaScript Driver 4.0.2 patch installed, you will need this snippet instead:

[source, javascript]
----
const uri = 'neo4j://graph.example.com:7687'
const driver = neo4j.driver(uri, auth, {
  encrypted: 'ENCRYPTION_ON'
})
----
| This is the default (and only option) for Neo4j Aura

|Neo4j 4.x
|Unsecured
|
[source, javascript]
----
neo4j.driver("neo4j://graph.example.com:7687", auth)
----
|This is the default for Neo4j 4.x series

|Neo4j 4.x
|Secured with full certificate
|
[source, javascript]
----
neo4j.driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the JavaScript Driver 4.0.2 patch installed, you will need this snippet instead:

[source, javascript]
----
const uri = 'neo4j://graph.example.com:7687'
const driver = neo4j.driver(uri, auth, {
  encrypted: 'ENCRYPTION_ON'
})
----
|

|Neo4j 4.x
|Secured with self-signed certificate
|
[source, javascript]
----
neo4j.driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the JavaScript Driver 4.0.2 patch installed, you will need this snippet instead:

[source, javascript]
----
const uri = 'neo4j://graph.example.com:7687'
const driver = neo4j.driver(uri, auth, {
  encrypted: 'ENCRYPTION_ON',
  trust: 'TRUST_ALL_CERTIFICATES'
})
----
|

|Neo4j 3.x
|Secured with full certificate
|
[source, javascript]
----
neo4j.driver("neo4j+s://graph.example.com:7687", auth)
----

If you do not have at least the JavaScript Driver 4.0.2 patch installed, you will need this snippet instead:

[source, javascript]
----
const uri = 'neo4j://graph.example.com:7687'
const driver = neo4j.driver(uri, auth, {
  encrypted: 'ENCRYPTION_ON'
})
----
|

|Neo4j 3.x
|Secured with self-signed certificate
|
[source, javascript]
----
neo4j.driver("neo4j+ssc://graph.example.com:7687", auth)
----

If you do not have at least the JavaScript Driver 4.0.2 patch installed, you will need this snippet instead:

[source, javascript]
----
const uri = 'neo4j://graph.example.com:7687'
const driver = neo4j.driver(uri, auth, {
  encrypted: 'ENCRYPTION_ON',
  trust: 'TRUST_ALL_CERTIFICATES'
})
----
|This is the default for Neo4j 3.x series

|Neo4j 3.x
|Unsecured
|
[source, javascript]
----
neo4j.driver("neo4j://graph.example.com:7687", auth)
----
|

|===

[NOTE]
To connect to a service without routing, you can replace `neo4j` with `bolt`.

======

[.include-with-python]
======
The table below illustrates examples of how to connect to a service with routing:

[options="header", cols="a,a,a,a"]
|===
|Product
|Security
|Code snippet
|Comments

|Neo4j Aura
|Secured with full certificate
|
[source, python]
----
GraphDatabase.driver("neo4j+s://graph.example.com:7687", auth)
----

For Python Driver versions before 4.0.0 you need this snippet instead:
[source, python]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth,
    "encrypted"=True, "trust"=TRUST_SYSTEM_CA_SIGNED_CERTIFICATES)
----
| This is the default (and only option) for Neo4j Aura

|Neo4j 4.x
|Unsecured
|
[source, python]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth)
----
|This is the default for Neo4j 4.x series

|Neo4j 4.x
|Secured with full certificate
|
[source, python]
----
GraphDatabase.driver("neo4j+s://graph.example.com:7687", auth)
----

For Python Driver versions before 4.0.0 you need this snippet instead:
[source, python]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth,
    "encrypted"=True, "trust"=TRUST_SYSTEM_CA_SIGNED_CERTIFICATES)
----
|

|Neo4j 4.x
|Secured with self-signed certificate
|
[source, python]
----
neo4j.driver("neo4j+ssc://graph.example.com:7687", auth)
----

For Python Driver versions before 4.0.0 you need this snippet instead:
[source, python]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth,
    "encrypted"=True, "trust"=TRUST_ALL_CERTIFICATES)
----
|

|Neo4j 3.x
|Secured with full certificate
|
[source, python]
----
neo4j.driver("neo4j+s://graph.example.com:7687", auth)
----

For Python Driver versions before 4.0.0 you need this snippet instead:
[source, python]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth,
    "encrypted"=True, "trust"=TRUST_SYSTEM_CA_SIGNED_CERTIFICATES)
----
|

|Neo4j 3.x
|Secured with self-signed certificate
|
[source, python]
----
neo4j.driver("neo4j+ssc://graph.example.com:7687", auth)
----

For Python Driver versions before 4.0.0 you need this snippet instead:
[source, python]
----
GraphDatabase.driver("neo4j://graph.example.com:7687", auth,
    "encrypted"=True, "trust"=TRUST_ALL_CERTIFICATES)
----
|This is the default for Neo4j 3.x series

|Neo4j 3.x
|Unsecured
|
[source, python]
----
neo4j.driver("neo4j://graph.example.com:7687", auth)
----
|

|===

[NOTE]
To connect to a service without routing, you can replace `neo4j` with `bolt`.

======

====


[[driver-authentication]]
== Authentication

# tag::authentication[]

Authentication details are provided as an auth token which contains the user names, passwords or other credentials required to access the database.
*Neo4j* supports multiple authentication standards but uses *_basic authentication_* by default.

# end::authentication[]


[[driver-authentication-basic]]
=== Basic authentication

# tag::authentication-basic[]

The basic authentication scheme is backed by a password file stored within the server and requires applications to provide a user name and password.
For this, use the basic auth helper:

# end::authentication-basic[]

[.tabbed-example]
.Basic authentication
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=basic-auth]
----

// .Import basic authentication
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=basic-auth-import]
// ----
======

[.include-with-java]
======
.Import basic authentication
[source, java]
----
include::{java-examples}/BasicAuthExample.java[tags=basic-auth-import]
----

[source, java]
----
include::{java-examples}/BasicAuthExample.java[tags=basic-auth]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=basic-auth]
----

// .Import basic authentication
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=basic-auth-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_basic_auth_example.py[tags=basic-auth-import]
----

[source, python]
----
include::{python-examples}/test_basic_auth_example.py[tags=basic-auth]
----
======

====

# tag::authentication-basic-note[]

[NOTE]
--
The basic authentication scheme can also be used to authenticate against an LDAP server.
--

# end::authentication-basic-note[]


[[driver-authentication-kerberos]]
=== Kerberos authentication

# tag::authentication-kerberos[]

The Kerberos authentication scheme provides a simple way to create a Kerberos authentication token with a base64 encoded server authentication ticket.
The best way to create a Kerberos authentication token is shown below:

# end::authentication-kerberos[]

[.tabbed-example]
.Kerberos authentication
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=kerberos-auth]
----

// .Import Kerberos authentication
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=kerberos-auth-import]
// ----
======

[.include-with-java]
======
.Import Kerberos authentication
[source, java]
----
include::{java-examples}/KerberosAuthExample.java[tags=kerberos-auth-import]
----

[source, java]
----
include::{java-examples}/KerberosAuthExample.java[tags=kerberos-auth]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=kerberos-auth]
----

// .Import Kerberos authentication
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=kerberos-auth-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_kerberos_auth_example.py[tags=kerberos-auth-import]
----

[source, python]
----
include::{python-examples}/test_kerberos_auth_example.py[tags=kerberos-auth]
----
======

====

# tag::authentication-kerberos-note[]

[NOTE]
--
The Kerberos authentication token can only be understood by the server if the server has the link:{kerberos-add-on-base-uri}[Kerberos Add-on] installed.
--

# end::authentication-kerberos-note[]


[[driver-authentication-custom]]
=== Custom authentication

# tag::authentication-custom[]

For advanced deployments, where a custom security provider has been built, the custom authentication helper can be used.

# end::authentication-custom[]

[.tabbed-example]
.Custom authentication
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=custom-auth]
----

// .Import custom authentication
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=custom-auth-import]
// ----
======

[.include-with-java]
======
.Import custom authentication
[source, java]
----
include::{java-examples}/CustomAuthExample.java[tags=custom-auth-import]
----

[source, java]
----
include::{java-examples}/CustomAuthExample.java[tags=custom-auth]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=custom-auth]
----
// .Import custom authentication
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=custom-auth-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_custom_auth_example.py[tags=custom-auth-import]
----

[source, python]
----
include::{python-examples}/test_custom_auth_example.py[tags=custom-auth]
----
======

====


[[driver-configuration]]
== Configuration

# tag::configuration-ConnectionAcquisitionTimeout[]

`ConnectionAcquisitionTimeout`::

The maximum amount of time a session will wait when requesting a connection from the connection pool.
For connection pools where all connections are currently being used and the `MaxConnectionPoolSize` limit has been reached, a session will wait this duration for a connection to be made available.
Since the process of acquiring a connection may involve creating a new connection, *_ensure that the value of this configuration is higher than the configured_* `ConnectionTimeout`.
+
Setting a low value will allow for transactions to *_fail fast_* when all connections in the pool have been acquired by other transactions.
Setting a higher value will result in these transactions being queued, increasing the chances of eventually acquiring a connection at the cost of longer time to receive feedback on failure.
Finding an optimal value may require an element of experimentation, taking into consideration the expected levels of parallelism within your application as well as the `MaxConnectionPoolSize`.
+
*Default:* 60 seconds

# end::configuration-ConnectionAcquisitionTimeout[]

[.tabbed-example]
.Configure connection pool
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-connection-pool]
----
// .Import connection pool configuration
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-connection-pool-import]
// ----
======


[.include-with-java]
======
.Import connection pool configuration
[source, java]
----
include::{java-examples}/ConfigConnectionPoolExample.java[tags=config-connection-pool-import]
----

[source, java]
----
include::{java-examples}/ConfigConnectionPoolExample.java[tags=config-connection-pool]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-connection-pool]
----

// .Import connection pool configuration
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=config-connection-pool-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_config_connection_pool_example.py[tags=config-connection-pool-import]
----

[source, python]
----
include::{python-examples}/test_config_connection_pool_example.py[tags=config-connection-pool]
----
======

====

# tag::configuration-ConnectionTimeout[]

`ConnectionTimeout`::

The maximum amount of time to wait for a TCP connection to be established.
Connections are only created when a session requires one unless there is an available connection in the connection pool.
The driver maintains a pool of open connections which can be loaned to a session when one is available.
If a connection is not available, then an attempt to create a new connection (provided the `MaxConnectionPoolSize` limit has not been reached) is made with this configuration option, providing the maximum amount of time to wait for the connection to be established.
+
In environments with high latency and high occurrences of connection timeouts it is recommended to configure a higher value.
For lower latency environments and quicker feedback on potential network issues configure with a lower value.
+
*Default:* 30 seconds

# end::configuration-ConnectionTimeout[]

[.tabbed-example]
.Configure connection timeout
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-connection-timeout]
----

// .Import connection timeout configuration
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-connection-timeout-import]
// ----
======


[.include-with-java]
======
.Import connection timeout configuration
[source, java]
----
include::{java-examples}/ConfigConnectionTimeoutExample.java[tags=config-connection-timeout-import]
----

[source, java]
----
include::{java-examples}/ConfigConnectionTimeoutExample.java[tags=config-connection-timeout]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-connection-timeout]
----
// .Import connection timeout configuration
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=config-connection-timeout-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_config_connection_timeout_example.py[tags=config-connection-timeout-import]
----

[source, python]
----
include::{python-examples}/test_config_connection_timeout_example.py[tags=config-connection-timeout]
----
======

====

# tag::configuration-CustomResolver[]

`CustomResolver`::

Specify a custom server address resolver used by the routing driver to resolve the initial address used to create the driver. See <<driver-resolver-function>> for more details.

# end::configuration-CustomResolver[]

# tag::configuration-Encryption[]

`Encryption`::

Specify whether to use an encrypted connection between the driver and server.
+
*Default:* None

# end::configuration-Encryption[]

[.tabbed-example]
.Unencrypted configuration
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-unencrypted]
----
// .Import unencrypted configuration
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-unencrypted-import]
// ----
======


[.include-with-java]
======
.Import unencrypted configuration
[source, java]
----
include::{java-examples}/ConfigUnencryptedExample.java[tags=config-unencrypted-import]
----

[source, java]
----
include::{java-examples}/ConfigUnencryptedExample.java[tags=config-unencrypted]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-unencrypted]
----
// .Import unencrypted configuration
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=config-unencrypted-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_config_unencrypted_example.py[tags=config-unencrypted-import]
----

[source, python]
----
include::{python-examples}/test_config_unencrypted_example.py[tags=config-unencrypted]
----
======

====

# tag::configuration-MaxConnectionLifetime[]

`MaxConnectionLifetime`::

The maximum duration the driver will keep a connection for before being removed from the pool.
Note that while the driver will respect this value, it is possible that the network environment will close connections inside this lifetime.
This is beyond the control of the driver.
The check on the connection’s lifetime happens when a session requires a connection.
If the available connection’s lifetime is over this limit it is closed and a new connection is created, added to the pool and returned to the requesting session.
Changing this configuration value would be useful in environments where users don’t have full control over the network environment and wish to proactively ensure all connections are ready.
+
Setting this option to a low value will cause a high connection churn rate, and can result in a performance drop.
It is recommended to pick a value smaller than the maximum lifetime exposed by the surrounding system infrastructure (such as operating system, router, load balancer, proxy and firewall).
Negative values result in lifetime not being checked.
+
*Default:* 1 hour (3600 seconds)

# end::configuration-MaxConnectionLifetime[]

# tag::configuration-MaxConnectionPoolSize[]

`MaxConnectionPoolSize`::

The maximum total number of connections allowed, per host (i.e. cluster nodes), to be managed by the connection pool.
In other words, for a direct driver using the `bolt://` scheme, this sets the maximum number of connections towards a single database server.
For a driver connected to a cluster using the `neo4j://` scheme, this sets the maximum amount of connections per cluster member.
If a session or transaction tries to acquire a connection at a time when the pool size is at its full capacity, it must wait until a free connection is available in the pool or the request to acquire a new connection times out.
The connection acquiring timeout is configured via `ConnectionAcquisitionTimeout`.
+
This configuration option allows you to manage the memory and I/O resources being used by the driver and tuning this option is dependent on these factors, in addition to number of cluster members.
+
*Default:* 100 connections (except .NET Driver with 500 connections)

# end::configuration-MaxConnectionPoolSize[]

# tag::configuration-MaxTransactionRetryTime[]

`MaxTransactionRetryTime`::

The maximum amount of time that a managed transaction will retry for before failing. Queries that are executed within a managed transaction gain the benefit of being retried when a transient error occurs.
When this happens the transaction is retired multiple times up to the `MaxTransactionRetryTime`.
+
Configure this option higher in high latency environments or if you are executing many large transactions which could limit the number of times that they are retired and therefore their chance to succeed.
Configure lower in low latency environments and where your workload mainly consists of many smaller transactions.
Failing transactions faster may highlight the reasons behind the transient errors making it easier to fix underlying issues.
+
*Default:* 30 seconds

# end::configuration-MaxTransactionRetryTime[]

[.tabbed-example]
.Configure maximum retry time
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-max-retry-time]
----
// .Import maximum retry time configuration
// [.include-with-dotnet]
// ======
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-max-retry-time-import]
// ----
======


[.include-with-java]
======
.Import maximum retry time configuration
[source, java]
----
include::{java-examples}/ConfigMaxRetryTimeExample.java[tags=config-max-retry-time-import]
----

[source, java]
----
include::{java-examples}/ConfigMaxRetryTimeExample.java[tags=config-max-retry-time]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-max-retry-time]
----
// .Import maximum retry time configuration
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=config-max-retry-time-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_config_max_retry_time_example.py[tags=config-max-retry-time-import]
----

[source, python]
----
include::{python-examples}/test_config_max_retry_time_example.py[tags=config-max-retry-time]
----
======

====

# tag::configuration-TrustStrategy[]

`TrustStrategy`::

Specify how to determine the authenticity of encryption certificates provided by the Neo4j instance that you are connecting to.
There are three choices as to which strategy to use:

* `TRUST_SYSTEM_CA_SIGNED_CERTIFICATES` - Accept any certificate that can be verified against a custom CA.

* `TRUST_CUSTOM_CA_SIGNED_CERTIFICATES` - Accept any certificate that can be verified against the system store.

* `TRUST_ALL_CERTIFICATES` - Accept any certificate provided by the server, regardless of CA chain. *We do not recommend using this setting for production environments.*

+
*Default:* `TRUST_SYSTEM_CA_SIGNED_CERTIFICATES` (Note - only when encryption is enabled)

# end::configuration-TrustStrategy[]

[.tabbed-example]
.Configure trusted certificates
====
[.include-with-dotnet]
======
[source, csharp]
----
include::{dotnet-examples}/Examples.cs[tags=config-trust]
----
// .Import trusted certificate configuration
// [source, csharp]
// ----
// include::{dotnet-examples}/Examples.cs[tags=config-trust-import]
// ----
======


[.include-with-java]
======
.Import trusted certificate configuration
[source, java]
----
include::{java-examples}/ConfigTrustExample.java[tags=config-trust-import]
----

[source, java]
----
include::{java-examples}/ConfigTrustExample.java[tags=config-trust]
----
======

[.include-with-javascript]
======
[source, javascript]
----
include::{javascript-examples}/examples.test.js[tags=config-trust]
----
// .Import trusted certificate configuration
// [source, javascript]
// ----
// include::{javascript-examples}/examples.test.js[tags=config-trust-import]
// ----
======

[.include-with-python]
======
[source, python]
----
include::{python-examples}/test_config_trust_example.py[tags=config-trust-import]
----

[source, python]
----
include::{python-examples}/test_config_trust_example.py[tags=config-trust]
----
======

====

# tag::configuration-KeepAlive[]

`KeepAlive`::

Specify whether TCP keep-alive should be enabled. To ensure that the connection between the driver and server is still operational, the TCP layer can periodically send messages to check the connection.
+
*Default:* True

# end::configuration-KeepAlive[]

[NOTE]
====
This is currently only configurable in the .NET Driver
====


[[driver-logging]]
== Logging

# tag::logging[]

All official *Neo4j Drivers* log information to standard logging channels.
This can typically be accessed in an ecosystem-specific way.

The code snippet below demonstrates how to redirect log messages to standard output:

# end::logging[]


[cols="2,2a"]
|===
| .NET
| [source, csharp]
#Please note that you will have to provide your own console logger implementing the ILogger interface.
IDriver driver = GraphDatabase.Driver(..., o => o.WithLogger(logger));
| Java
| [source, java]
 ConfigBuilder.withLogging(Logging.console(Level.DEBUG))
| JavaScript
| [source, javascript]
const loggingConfig = {logging: neo4j.logging.console('debug')};
const driver = neo4j.driver(..., loggingConfig);
| Python
| [source, python]
from logging import getLogger, StreamHandler, DEBUG
handler = StreamHandler()
handler.setLevel(DEBUG)
getLogger("neo4j").addHandler(handler)
|===
