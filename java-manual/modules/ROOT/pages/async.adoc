= Run non-blocking asynchronous queries


[source, java]
----
package demo;

import java.util.Map;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import org.neo4j.driver.async.AsyncSession;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.summary.ResultSummary;
import org.neo4j.driver.SessionConfig;

public class App {

    public static void main(String... args) throws ExecutionException, InterruptedException {
        final String dbUri = "neo4j://localhost";
        final String dbUser = "neo4j";
        final String dbPassword = "verysecret";

        try (var driver = GraphDatabase.driver(dbUri, AuthTokens.basic(dbUser, dbPassword))) {  // <1>
            driver.verifyConnectivity();
            var summary = printAllProducts(driver);
            // Block as long as necessary
            System.out.println(summary.get());  // <7>
        }
    }

    public static CompletableFuture<ResultSummary> printAllProducts(Driver driver) {
        var query = "MERGE (p:Person {name: $name}) RETURN p.name";
        var session = driver.session(AsyncSession.class, SessionConfig.builder().withDatabase("neo4j").build());  // <2>
        var summary = session.executeWriteAsync(tx -> tx.runAsync(query, Map.of("name", "Olivia")) // <3>
                .thenCompose(resCursor -> resCursor.forEachAsync(record -> {  // <4>
                    System.out.println(record.get(0).asString());
                })))
            .whenComplete((result, error) -> {  // <5>
                session.closeAsync();
            })
            .toCompletableFuture();  // <6>
        return summary;
    }
}
----

<1> l
<1> l
<1> l


ifndef::backend-pdf[]
[discrete.glossary]
== Glossary

include::{common-partial}/glossary.adoc[]
include::../partials/glossary.adoc[]
endif::[]
