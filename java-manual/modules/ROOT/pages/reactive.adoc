= Control results flow with reactive streams

Typical of reactive programming, in a reactive flow consumers control the rate at which they consume records from queries, and the driver in turn manages the rate at which records are requested from the server.
The reactive API ensures that the receiving side is not forced to buffer arbitrary amounts of data.


[source, java]
----
package demo;

import java.util.Map;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import org.neo4j.driver.async.AsyncSession;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.summary.ResultSummary;
import org.neo4j.driver.SessionConfig;

public class App {

    public static void main(String... args) throws ExecutionException, InterruptedException {
        final String dbUri = "neo4j://localhost";
        final String dbUser = "neo4j";
        final String dbPassword = "verysecret";

        try (var driver = GraphDatabase.driver(dbUri, AuthTokens.basic(dbUser, dbPassword))) {
            driver.verifyConnectivity();
            var summary = printAllPeople(driver);
            // Block as long as necessary
            System.out.println(summary.get());
        }
    }

    public Flux<ResultSummary> printAllPeople() {
        var query = """
        UNWIND ['Alice', 'Bob', 'Sofia', 'Charles'] AS name
        MERGE (p:Person {name: $name}) RETURN p.name
        """;

        return Flux.usingWhen(
            Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
            session -> flowPublisherToFlux(session.executeRead(tx -> {
                var resultRef = new AtomicReference<ReactiveResult>();
                var flux = flowPublisherToFlux(tx.run(query))
                        .doOnNext(resultRef::set)
                        .flatMap(result -> flowPublisherToFlux(result.records()))
                        .doOnNext(record -> System.out.println(record.get(0).asString()))
                        .then(Mono.defer(() -> Mono.from(flowPublisherToFlux(resultRef.get().consume()))));
                return publisherToFlowPublisher(flux);
            })),
            session -> flowPublisherToFlux(session.close()));
    }
}


----

[source, java]
----
public Flux<String> readProductTitles() {
    var query = new Query("MATCH (p:Product) WHERE p.id = $id RETURN p.title", Collections.singletonMap("id", 0));
    return Flux.usingWhen(
            Mono.fromSupplier(() -> driver.session(ReactiveSession.class)),
            session -> flowPublisherToFlux(session.run(query))
                    .flatMap(result -> flowPublisherToFlux(result.records()))
                    .map(record -> record.get(0).asString()),
            session -> flowPublisherToFlux(session.close()));
}
----


ifndef::backend-pdf[]
[discrete.glossary]
== Glossary

include::{common-partial}/glossary.adoc[]
include::../partials/glossary.adoc[]
endif::[]
