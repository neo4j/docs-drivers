= Control results flow with reactive streams

Typical of reactive programming, in a reactive flow consumers control the rate at which they consume records from queries, and the driver in turn manages the rate at which records are requested from the server.
The reactive API ensures that the receiving side is not forced to buffer arbitrary amounts of data.


[source, java]
----
package demo;

import java.util.Map;
import java.util.concurrent.CompletionStage;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;

import org.neo4j.driver.async.AsyncSession;
import org.neo4j.driver.AuthTokens;
import org.neo4j.driver.Driver;
import org.neo4j.driver.GraphDatabase;
import org.neo4j.driver.summary.ResultSummary;
import org.neo4j.driver.SessionConfig;

public class App {

    @Test
    void demoSessionRun() {
        var config = Config.builder()
                .withLogging(Logging.console(Level.FINE))
                .build();
        var driver = GraphDatabase.driver(neo4j.uri(), neo4j.authTokenManager(), config);

        var records = Flux.usingWhen(
                Mono.just(driver.session(ReactiveSession.class)),
                reactiveSession -> Mono.fromDirect(reactiveSession.run("UNWIND range (1, 5) AS x RETURN x")).flatMapMany(ReactiveResult::records),
                ReactiveSession::close);

        // block for demonstration purposes
        var values = records.map(record -> record.get("x")).collectList().block();
        System.out.println(values);

        driver.close();
    }

    @Test
    void demoSessionExecuteRead() {
        var config = Config.builder()
                .withLogging(Logging.console(Level.FINE))
                .build();
        var driver = GraphDatabase.driver(neo4j.uri(), neo4j.authTokenManager(), config);

        var records = Flux.usingWhen(
                Mono.just(driver.session(ReactiveSession.class)),
                reactiveSession -> Mono.fromDirect(reactiveSession.executeRead(tx -> Mono.fromDirect(tx.run("UNWIND range (1, 5) AS x RETURN x")).flatMapMany(ReactiveResult::records))),
                ReactiveSession::close);

        // block for demonstration purposes
        var values = records.map(record -> record.get("x")).collectList().block();
        System.out.println(values);

        driver.close();
    }

}


----


ifndef::backend-pdf[]
[discrete.glossary]
== Glossary

include::{common-partial}/glossary.adoc[]
include::../partials/glossary.adoc[]
endif::[]
